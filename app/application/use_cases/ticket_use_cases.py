"""Ticket use cases"""
from typing import List, Optional
from app.domain.entities.ticket import Ticket, Comment, TicketStatus, TicketPriority, TicketCategory
from app.domain.repositories.ticket_repository import TicketRepository
from app.domain.repositories.user_repository import UserRepository
from app.application.dto.ticket_dto import (
    TicketCreateDTO,
    TicketUpdateDTO,
    TicketResponseDTO,
    CommentCreateDTO,
    CommentResponseDTO,
)


class TicketUseCases:
    """Ticket use cases"""

    def __init__(self, ticket_repository: TicketRepository, user_repository: UserRepository):
        self.ticket_repository = ticket_repository
        self.user_repository = user_repository

    async def create_ticket(
        self, ticket_data: TicketCreateDTO, created_by_user_id: str
    ) -> TicketResponseDTO:
        """Create a new ticket
        
        Args:
            ticket_data: Ticket creation data
            created_by_user_id: ID of the user creating the ticket
        """
        # Get user to get username and email
        user = await self.user_repository.get_by_id(created_by_user_id)
        if not user:
            raise ValueError(f"User with ID '{created_by_user_id}' not found")

        # Create domain entity
        ticket = Ticket(
            id="",  # Will be generated by repository
            title=ticket_data.title,
            description=ticket_data.description,
            priority=ticket_data.priority,
            status=TicketStatus.OPEN,
            category=ticket_data.category,
            created_by=created_by_user_id,
            created_by_name=user.username,
            created_by_email=user.email,
            comments=[],
        )

        # Create ticket via repository
        created_ticket = await self.ticket_repository.create(ticket)

        # Convert to DTO
        return self._ticket_to_dto(created_ticket)

    async def get_ticket(self, ticket_id: str) -> Optional[TicketResponseDTO]:
        """Get ticket by ID"""
        ticket = await self.ticket_repository.get_by_id(ticket_id)
        if not ticket:
            return None

        return self._ticket_to_dto(ticket)

    async def get_all_tickets(self) -> List[TicketResponseDTO]:
        """Get all tickets"""
        tickets = await self.ticket_repository.get_all()
        return [self._ticket_to_dto(ticket) for ticket in tickets]

    async def get_user_tickets(self, user_id: str) -> List[TicketResponseDTO]:
        """Get tickets created by user"""
        tickets = await self.ticket_repository.get_by_user_id(user_id)
        return [self._ticket_to_dto(ticket) for ticket in tickets]

    async def update_ticket(
        self, ticket_id: str, ticket_data: TicketUpdateDTO, current_user_role: str
    ) -> Optional[TicketResponseDTO]:
        """Update ticket
        
        Args:
            ticket_id: Ticket ID
            ticket_data: Ticket update data
            current_user_role: Role of the user updating the ticket
        """
        ticket = await self.ticket_repository.get_by_id(ticket_id)
        if not ticket:
            return None

        # Check if user can close ticket (only admin and it)
        if ticket_data.status == TicketStatus.CLOSED:
            if current_user_role not in ["admin", "it"]:
                raise ValueError("Only administrators and IT staff can close tickets")

        # Update fields
        if ticket_data.title is not None:
            ticket.title = ticket_data.title
        if ticket_data.description is not None:
            ticket.description = ticket_data.description
        if ticket_data.priority is not None:
            ticket.priority = ticket_data.priority
        if ticket_data.status is not None:
            ticket.status = ticket_data.status
        if ticket_data.category is not None:
            ticket.category = ticket_data.category
        # Handle assigned_to - can be None to unassign, or a user ID to assign
        if hasattr(ticket_data, 'assigned_to') and ticket_data.assigned_to is not None:
            # Get assigned user to get username
            assigned_user = await self.user_repository.get_by_id(ticket_data.assigned_to)
            if assigned_user:
                ticket.assigned_to = ticket_data.assigned_to
                ticket.assigned_to_name = assigned_user.username
            else:
                ticket.assigned_to = None
                ticket.assigned_to_name = None
        elif hasattr(ticket_data, 'assigned_to') and ticket_data.assigned_to is None:
            # Explicitly unassign
            ticket.assigned_to = None
            ticket.assigned_to_name = None
        if hasattr(ticket_data, 'estimated_time') and ticket_data.estimated_time is not None:
            ticket.estimated_time = ticket_data.estimated_time
        elif hasattr(ticket_data, 'estimated_time') and ticket_data.estimated_time is None:
            ticket.estimated_time = None

        updated_ticket = await self.ticket_repository.update(ticket)

        return self._ticket_to_dto(updated_ticket)

    async def delete_ticket(self, ticket_id: str) -> bool:
        """Delete ticket"""
        return await self.ticket_repository.delete(ticket_id)

    async def add_comment(
        self, ticket_id: str, comment_data: CommentCreateDTO, author_user_id: str
    ) -> TicketResponseDTO:
        """Add comment to ticket
        
        Args:
            ticket_id: Ticket ID
            comment_data: Comment creation data
            author_user_id: ID of the user adding the comment
        """
        # Get ticket
        ticket = await self.ticket_repository.get_by_id(ticket_id)
        if not ticket:
            raise ValueError(f"Ticket with ID '{ticket_id}' not found")

        # Get user to get username
        user = await self.user_repository.get_by_id(author_user_id)
        if not user:
            raise ValueError(f"User with ID '{author_user_id}' not found")

        # Create comment
        comment = Comment(
            id="",  # Will be generated by repository
            text=comment_data.text,
            author_id=author_user_id,
            author_name=user.username,
            created_at=None,  # Will be set by repository
        )

        # Add comment via repository
        updated_ticket = await self.ticket_repository.add_comment(ticket_id, comment)

        return self._ticket_to_dto(updated_ticket)

    def _ticket_to_dto(self, ticket: Ticket) -> TicketResponseDTO:
        """Convert Ticket entity to TicketResponseDTO"""
        return TicketResponseDTO(
            id=ticket.id,
            title=ticket.title,
            description=ticket.description,
            priority=ticket.priority,
            status=ticket.status,
            category=ticket.category,
            created_by=ticket.created_by,
            created_by_name=ticket.created_by_name,
            created_by_email=ticket.created_by_email,
            assigned_to=ticket.assigned_to,
            assigned_to_name=ticket.assigned_to_name,
            created_at=ticket.created_at,
            updated_at=ticket.updated_at,
            comments=[
                CommentResponseDTO(
                    id=comment.id,
                    text=comment.text,
                    author_id=comment.author_id,
                    author_name=comment.author_name,
                    created_at=comment.created_at,
                )
                for comment in (ticket.comments or [])
            ],
        )


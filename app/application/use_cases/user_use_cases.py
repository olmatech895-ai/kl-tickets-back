"""User use cases"""
from typing import List, Optional
from app.domain.entities.user import User, UserRole
from app.domain.repositories.user_repository import UserRepository
from app.application.dto.user_dto import (
    UserCreateDTO,
    UserUpdateDTO,
    UserResponseDTO,
)


class UserUseCases:
    """User use cases"""

    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository

    async def create_user(self, user_data: UserCreateDTO, created_by_role: Optional[UserRole] = None) -> UserResponseDTO:
        """Create a new user
        
        Args:
            user_data: User creation data
            created_by_role: Role of the user creating this user (for validation)
        """
        # Check if user already exists
        existing_user = await self.user_repository.get_by_username(user_data.username)
        if existing_user:
            raise ValueError(f"User with username '{user_data.username}' already exists")

        # Validate email domain (@kostalegal.com)
        if not user_data.email.lower().endswith('@kostalegal.com'):
            raise ValueError("Email must be from domain @kostalegal.com")

        # Check if email already exists
        all_users = await self.user_repository.get_all()
        if any(u.email.lower() == user_data.email.lower() for u in all_users):
            raise ValueError(f"User with email '{user_data.email}' already exists")
        
        # Validate role assignment: only admin can create users with admin or it roles
        if user_data.role in [UserRole.ADMIN, UserRole.IT]:
            if created_by_role != UserRole.ADMIN:
                raise ValueError("Only administrators can create users with admin or IT roles")

        # Create domain entity
        user = User(
            id="",  # Will be generated by repository
            username=user_data.username,
            email=user_data.email,
            role=user_data.role,
        )

        # Create user via repository (no password)
        created_user = await self.user_repository.create(user)

        # Convert to DTO
        return UserResponseDTO(
            id=created_user.id,
            username=created_user.username,
            email=created_user.email,
            role=created_user.role,
            blocked=created_user.blocked,
            created_at=created_user.created_at,
            updated_at=created_user.updated_at,
        )

    async def get_user(self, user_id: str) -> Optional[UserResponseDTO]:
        """Get user by ID"""
        user = await self.user_repository.get_by_id(user_id)
        if not user:
            return None

        return UserResponseDTO(
            id=user.id,
            username=user.username,
            email=user.email,
            role=user.role,
            blocked=user.blocked,
            created_at=user.created_at,
            updated_at=user.updated_at,
        )

    async def get_all_users(self) -> List[UserResponseDTO]:
        """Get all users"""
        users = await self.user_repository.get_all()
        return [
            UserResponseDTO(
                id=user.id,
                username=user.username,
                email=user.email,
                role=user.role,
                blocked=user.blocked,
                created_at=user.created_at,
                updated_at=user.updated_at,
            )
            for user in users
        ]

    async def update_user(
        self, user_id: str, user_data: UserUpdateDTO
    ) -> Optional[UserResponseDTO]:
        """Update user"""
        user = await self.user_repository.get_by_id(user_id)
        if not user:
            return None

        # Update fields
        if user_data.username is not None:
            user.username = user_data.username
        if user_data.email is not None:
            user.email = user_data.email
        if user_data.role is not None:
            user.role = user_data.role
        if user_data.blocked is not None:
            user.blocked = user_data.blocked

        updated_user = await self.user_repository.update(user)

        return UserResponseDTO(
            id=updated_user.id,
            username=updated_user.username,
            email=updated_user.email,
            role=updated_user.role,
            blocked=updated_user.blocked,
            created_at=updated_user.created_at,
            updated_at=updated_user.updated_at,
        )

    async def delete_user(self, user_id: str) -> bool:
        """Delete user"""
        return await self.user_repository.delete(user_id)

    async def authenticate_user(self, email: str) -> Optional[UserResponseDTO]:
        """Authenticate by email only (no password). User must exist in DB."""
        user = await self.user_repository.get_by_email(email)
        if not user:
            return None

        return UserResponseDTO(
            id=user.id,
            username=user.username,
            email=user.email,
            role=user.role,
            blocked=user.blocked,
            created_at=user.created_at,
            updated_at=user.updated_at,
        )

